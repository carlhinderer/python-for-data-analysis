------------------------------------------------------
CHAPTER 08 - DATA WRANGLING
------------------------------------------------------

- Hierarchical Indexing

    'Hierarchical indexing' is an important feature of pandas that enables you to have
      2 or more index levels on an axis.  It provides a way to work with higher dimensional
      data in a lower dimensional form.


    # Create a series with a hierarchical index
    >>> data = pd.Series(np.random.randn(9),
                         index=[['a', 'a', 'a', 'b', 'b', 'c', 'c', 'd', 'd'],
                                [1, 2, 3, 1, 3, 1, 2, 2, 3]])
    >>> data
    a  1   -0.204708
       2    0.478943
       3   -0.519439
    b  1   -0.555730
       3    1.965781
    c  1    1.393406
       2    0.092908
    d  2    0.281746
       3    0.769023
    dtype: float64

    >>> data.index
    MultiIndex(levels=[['a', 'b', 'c', 'd'], [1, 2, 3]],
               labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 2, 0, 1, 1, 2]])


    # With a hierarchical indexed object, partial indexing can be used
    >>> data['b']
    1   -0.555730
    3    1.965781
    dtype: float64

    >>> data['b':'c'] 
    b  1   -0.555730
       3    1.965781
    c  1    1.393406
       2    0.092908
    dtype: float64

    >>> data.loc[['b', 'd']]
    b  1   -0.555730
       3    1.965781
    d  2    0.281746
       3    0.769023
    dtype: float64


    # Selection from an inner level is possible
    >>> data.loc[:, 2]
    a    0.478943
    c    0.092908
    d    0.281746
    dtype: float64



- Stacking and Unstacking

    Hierarchical indexing plays an important role in reshaping data and group-based operations
      like forming a pivot table.  


    # Unstacking into a flat DataFrame
    >>> data.unstack()

              1         2         3
    a -0.204708  0.478943 -0.519439
    b -0.555730       NaN  1.965781
    c  1.393406  0.092908       NaN
    d       NaN  0.281746  0.769023


    # Stacking is the opposite of unstacking
    >>> data.unstack().stack()

    a  1   -0.204708
       2    0.478943
       3   -0.519439
    b  1   -0.555730
       3    1.965781
    c  1    1.393406
       2    0.092908
    d  2    0.281746
       3    0.769023
    dtype: float64



- Column-Level Hierarchical Indexes

    # Either axis of a DataFrame can have a hierarchical index
    >>> frame = pd.DataFrame(np.arange(12).reshape((4, 3)),
                             index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],
                             columns=[['Ohio', 'Ohio', 'Colorado'],
                                      ['Green', 'Red', 'Green']])
    >>> frame
    
           Ohio     Colorado
        Green Red    Green
    a 1     0   1        2
      2     3   4        5
    b 1     6   7        8
      2     9  10       11


   # Select from hierarchical column
   >>> frame['Ohio']

    color      Green  Red
    key1 key2            
    a    1         0    1
         2         3    4
    b    1         6    7
         2         9   10



- Reordering and Sorting Levels

    At times, we will need to rearrange the order of the levels on the axis or sort the data
      by the values in one specific level.  The 'swaplevel' takes 2 level numbers or names
      and returns a new object with the levels interchanges.


    >>> frame.swaplevel('key1', 'key2')

    state      Ohio     Colorado
    color     Green Red    Green
    key2 key1                   
    1    a        0   1        2
    2    a        3   4        5
    1    b        6   7        8
    2    b        9  10       11


    The 'sort_index' method sorts the data using only the values in a single level.  When
      swapping levels, it's not uncommon to also use 'sort_index' so that the result is
      lexicographically sorted by the indicated level.


    # Sort on 'key2'
    >>> frame.sort_index(level=1)

    state      Ohio     Colorado
    color     Green Red    Green
    key1 key2                   
    a    1        0   1        2
    b    1        6   7        8
    a    2        3   4        5
    b    2        9  10       11
    

    >>> frame.swaplevel(0, 1).sort_index(level=0)
    Out[26]: 
    state      Ohio     Colorado
    color     Green Red    Green
    key2 key1                   
    1    a        0   1        2
         b        6   7        8
    2    a        3   4        5
         b        9  10       11



- Summary Statistics by Level

    Many of the DataFrame's descriptive and summary statistics have a 'level' option in 
      which you can specify the level you want to aggregate on a particular axis.


    # Aggregate rows
    >>> frame.sum(level='key2')

    state  Ohio     Colorado
    color Green Red    Green
    key2                    
    1         6   8       10
    2        12  14       16
    

    # Aggregate columns
    >>> frame.sum(level='color', axis=1)

    color      Green  Red
    key1 key2            
    a    1         2    1
         2         8    4
    b    1        14    7
         2        20   10



- Indexing With a DataFrame's Columns

    # Create a DataFrame
    >>> frame = pd.DataFrame({'a': range(7), 
                              'b': range(7, 0, -1),
                              'c': ['one', 'one', 'one', 'two', 'two', 'two', 'two'],
                              'd': [0, 1, 2, 0, 1, 2, 3]})
    >>> frame
 
       a  b    c  d
    0  0  7  one  0
    1  1  6  one  1
    2  2  5  one  2
    3  3  4  two  0
    4  4  3  two  1
    5  5  2  two  2
    6  6  1  two  3


    # Use 'set_index' to use columns as the index
    >>> frame2 = frame.set_index(['c', 'd'])
    >>> frame2

            a  b
    c    d      
    one  0  0  7
         1  1  6
         2  2  5
    two  0  3  4
         1  4  3
         2  5  2
         3  6  1


    # Use the columns as indexes, but keep the columns
    >>> frame.set_index(['c', 'd'], drop=False)

           a  b    c  d
    c   d              
    one 0  0  7  one  0
        1  1  6  one  1
        2  2  5  one  2
    two 0  3  4  two  0
        1  4  3  two  1
        2  5  2  two  2
        3  6  1  two  3
    
    
    # 'reset_index' does the opposite of 'set_index':
    >>> frame2.reset_index()
    
         c  d  a  b
    0  one  0  0  7
    1  one  1  1  6
    2  one  2  2  5
    3  two  0  3  4
    4  two  1  4  3
    5  two  2  5  2
    6  two  3  6  1



- Combining and Merging Datasets

    There are a number of different ways to combine pandas objects:

      1. 'pandas.merge' connects rows in DataFrames based on one or more keys, similarly
           to a SQL JOIN

      2. 'pandas.concat' concatenates (or 'stacks') objects together along an axis

      3. The 'combine_first' instance method enables splicing together overlapping data to
           fill in missing values in one object from another



- Database-Style DataFrame Joins

    Merge operations combine datasets by linking rows using one or more keys.


    # Create 2 DataFrames
    >>> df1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
                            'data1': range(7)})
    >>> df2 = pd.DataFrame({'key': ['a', 'b', 'd'],
                            'data2': range(3)})
    >>> df1
       data1 key
    0      0   b
    1      1   b
    2      2   a
    3      3   c
    4      4   a
    5      5   a
    6      6   b
    
    >>> df2
       data2 key
    0      0   a
    1      1   b
    2      2   d


    # Perform a many-to-one join, since df1 has multiple rows labeled 'a' and 'b',
    #   whereas df2 only has one row for each value in the 'key' column
    >>> pd.merge(df1, df2)

       data1 key  data2
    0      0   b      1
    1      1   b      1
    2      6   b      1
    3      2   a      0
    4      4   a      0
    5      5   a      0


    # Note that if the merge key is not specified, 'merge' uses the overlapping columns
    #   as keys (but it's a best practice to specify the key explicitly)
    >>> pd.merge(df1, df2, on='key')


    # If the column manes are different in each object, they can be specified separately
    >>> df3 = pd.DataFrame({'lkey': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
                            'data1': range(7)})

    >>> df4 = pd.DataFrame({'rkey': ['a', 'b', 'd'],
                            'data2': range(3)})

    >>> pd.merge(df3, df4, left_on='lkey', right_on='rkey')



- Outer Joins

    # Take the outer join
    >>> pd.merge(df1, df2, how='outer')

       data1 key  data2
    0    0.0   b    1.0
    1    1.0   b    1.0
    2    6.0   b    1.0
    3    2.0   a    0.0
    4    4.0   a    0.0
    5    5.0   a    0.0
    6    3.0   c    NaN
    7    NaN   d    2.0



- List of Different Join Types with the 'how' Argument

    Option	    Behavior
    -----------------------------------------------------------------------
    'inner'	    Use only the key combinations observed in both tables
    'left'	    Use all key combinations found in the left table
    'right'	    Use all key combinations found in the right table
    'outer'	    Use all key combinations observed in both tables together



- Many-to-Many Merges

    # Create DataSets
    >>> df1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'b'],
                            'data1': range(6)})

    >>> df2 = pd.DataFrame({'key': ['a', 'b', 'a', 'b', 'd'],
                            'data2': range(5)})
    >>> df1
       data1 key
    0      0   b
    1      1   b
    2      2   a
    3      3   c
    4      4   a
    5      5   b
    
    >>> df2
       data2 key
    0      0   a
    1      1   b
    2      2   a
    3      3   b
    4      4   d


    # Many-to-many merge to get the Cartesian product
    >>> pd.merge(df1, df2, on='key', how='left')

        data1 key  data2
    0       0   b    1.0
    1       0   b    3.0
    2       1   b    1.0
    3       1   b    3.0
    4       2   a    0.0
    5       2   a    2.0
    6       3   c    NaN
    7       4   a    0.0
    8       4   a    2.0
    9       5   b    1.0
    10      5   b    3.0



- Merging with Multiple Keys

    >>> left = pd.DataFrame({'key1': ['foo', 'foo', 'bar'],
                             'key2': ['one', 'two', 'one'],
                             'lval': [1, 2, 3]})

    >>> right = pd.DataFrame({'key1': ['foo', 'foo', 'bar', 'bar'],
                              'key2': ['one', 'one', 'one', 'two'],
                              'rval': [4, 5, 6, 7]})

    # Merge on composite key
    >>> pd.merge(left, right, on=['key1', 'key2'], how='outer')
 
      key1 key2  lval  rval
    0  foo  one   1.0   4.0
    1  foo  one   1.0   5.0
    2  foo  two   2.0   NaN
    3  bar  one   3.0   6.0
    4  bar  two   NaN   7.0


    # Merge also has the 'suffixes' option to specify strings to append to overlaping names
    >>> pd.merge(left, right, on='key1')

      key1 key2_x  lval key2_y  rval
    0  foo    one     1    one     4
    1  foo    one     1    one     5
    2  foo    two     2    one     4
    3  foo    two     2    one     5
    4  bar    one     3    one     6
    5  bar    one     3    two     7
    
    >>> pd.merge(left, right, on='key1', suffixes=('_left', '_right'))

      key1 key2_left  lval key2_right  rval
    0  foo       one     1        one     4
    1  foo       one     1        one     5
    2  foo       two     2        one     4
    3  foo       two     2        one     5
    4  bar       one     3        one     6
    5  bar       one     3        two     7



- List of Merge Function Arguments

- Merging on Index

- Concatenating Along An Axis

- List of 'concat' Function Arguments

- Combining Data With Overlap

- Reshaping With Hierarchical Indexing

- Pivoting 'Long' to 'Wide' Format

- Pivoting 'Wide' to 'Long' Format