------------------------------------------------------
CHAPTER 08 - DATA WRANGLING
------------------------------------------------------

- Hierarchical Indexing

    'Hierarchical indexing' is an important feature of pandas that enables you to have
      2 or more index levels on an axis.  It provides a way to work with higher dimensional
      data in a lower dimensional form.


    # Create a series with a hierarchical index
    >>> data = pd.Series(np.random.randn(9),
                         index=[['a', 'a', 'a', 'b', 'b', 'c', 'c', 'd', 'd'],
                                [1, 2, 3, 1, 3, 1, 2, 2, 3]])
    >>> data
    a  1   -0.204708
       2    0.478943
       3   -0.519439
    b  1   -0.555730
       3    1.965781
    c  1    1.393406
       2    0.092908
    d  2    0.281746
       3    0.769023
    dtype: float64

    >>> data.index
    MultiIndex(levels=[['a', 'b', 'c', 'd'], [1, 2, 3]],
               labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 2, 0, 1, 1, 2]])


    # With a hierarchical indexed object, partial indexing can be used
    >>> data['b']
    1   -0.555730
    3    1.965781
    dtype: float64

    >>> data['b':'c'] 
    b  1   -0.555730
       3    1.965781
    c  1    1.393406
       2    0.092908
    dtype: float64

    >>> data.loc[['b', 'd']]
    b  1   -0.555730
       3    1.965781
    d  2    0.281746
       3    0.769023
    dtype: float64


    # Selection from an inner level is possible
    >>> data.loc[:, 2]
    a    0.478943
    c    0.092908
    d    0.281746
    dtype: float64



- Stacking and Unstacking

    Hierarchical indexing plays an important role in reshaping data and group-based operations
      like forming a pivot table.  


    # Unstacking into a flat DataFrame
    >>> data.unstack()

              1         2         3
    a -0.204708  0.478943 -0.519439
    b -0.555730       NaN  1.965781
    c  1.393406  0.092908       NaN
    d       NaN  0.281746  0.769023


    # Stacking is the opposite of unstacking
    >>> data.unstack().stack()

    a  1   -0.204708
       2    0.478943
       3   -0.519439
    b  1   -0.555730
       3    1.965781
    c  1    1.393406
       2    0.092908
    d  2    0.281746
       3    0.769023
    dtype: float64



- Column-Level Hierarchical Indexes

    # Either axis of a DataFrame can have a hierarchical index
    >>> frame = pd.DataFrame(np.arange(12).reshape((4, 3)),
                             index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],
                             columns=[['Ohio', 'Ohio', 'Colorado'],
                                      ['Green', 'Red', 'Green']])
    >>> frame
    
           Ohio     Colorado
        Green Red    Green
    a 1     0   1        2
      2     3   4        5
    b 1     6   7        8
      2     9  10       11


   # Select from hierarchical column
   >>> frame['Ohio']

    color      Green  Red
    key1 key2            
    a    1         0    1
         2         3    4
    b    1         6    7
         2         9   10



- Reordering and Sorting Levels

    At times, we will need to rearrange the order of the levels on the axis or sort the data
      by the values in one specific level.  The 'swaplevel' takes 2 level numbers or names
      and returns a new object with the levels interchanges.


    >>> frame.swaplevel('key1', 'key2')

    state      Ohio     Colorado
    color     Green Red    Green
    key2 key1                   
    1    a        0   1        2
    2    a        3   4        5
    1    b        6   7        8
    2    b        9  10       11


    The 'sort_index' method sorts the data using only the values in a single level.  When
      swapping levels, it's not uncommon to also use 'sort_index' so that the result is
      lexicographically sorted by the indicated level.


    # Sort on 'key2'
    >>> frame.sort_index(level=1)

    state      Ohio     Colorado
    color     Green Red    Green
    key1 key2                   
    a    1        0   1        2
    b    1        6   7        8
    a    2        3   4        5
    b    2        9  10       11
    

    >>> frame.swaplevel(0, 1).sort_index(level=0)
    Out[26]: 
    state      Ohio     Colorado
    color     Green Red    Green
    key2 key1                   
    1    a        0   1        2
         b        6   7        8
    2    a        3   4        5
         b        9  10       11



- Summary Statistics by Level

    Many of the DataFrame's descriptive and summary statistics have a 'level' option in 
      which you can specify the level you want to aggregate on a particular axis.


    # Aggregate rows
    >>> frame.sum(level='key2')

    state  Ohio     Colorado
    color Green Red    Green
    key2                    
    1         6   8       10
    2        12  14       16
    

    # Aggregate columns
    >>> frame.sum(level='color', axis=1)

    color      Green  Red
    key1 key2            
    a    1         2    1
         2         8    4
    b    1        14    7
         2        20   10



- Indexing With a DataFrame's Columns

    # Create a DataFrame
    >>> frame = pd.DataFrame({'a': range(7), 
                              'b': range(7, 0, -1),
                              'c': ['one', 'one', 'one', 'two', 'two', 'two', 'two'],
                              'd': [0, 1, 2, 0, 1, 2, 3]})
    >>> frame
 
       a  b    c  d
    0  0  7  one  0
    1  1  6  one  1
    2  2  5  one  2
    3  3  4  two  0
    4  4  3  two  1
    5  5  2  two  2
    6  6  1  two  3


    # Use 'set_index' to use columns as the index
    >>> frame2 = frame.set_index(['c', 'd'])
    >>> frame2

            a  b
    c    d      
    one  0  0  7
         1  1  6
         2  2  5
    two  0  3  4
         1  4  3
         2  5  2
         3  6  1


    # Use the columns as indexes, but keep the columns
    >>> frame.set_index(['c', 'd'], drop=False)

           a  b    c  d
    c   d              
    one 0  0  7  one  0
        1  1  6  one  1
        2  2  5  one  2
    two 0  3  4  two  0
        1  4  3  two  1
        2  5  2  two  2
        3  6  1  two  3
    
    
    # 'reset_index' does the opposite of 'set_index':
    >>> frame2.reset_index()
    
         c  d  a  b
    0  one  0  0  7
    1  one  1  1  6
    2  one  2  2  5
    3  two  0  3  4
    4  two  1  4  3
    5  two  2  5  2
    6  two  3  6  1



- Combining and Merging Datasets

    There are a number of different ways to combine pandas objects:

      1. 'pandas.merge' connects rows in DataFrames based on one or more keys, similarly
           to a SQL JOIN

      2. 'pandas.concat' concatenates (or 'stacks') objects together along an axis

      3. The 'combine_first' instance method enables splicing together overlapping data to
           fill in missing values in one object from another



- Database-Style DataFrame Joins

    Merge operations combine datasets by linking rows using one or more keys.


    # Create 2 DataFrames
    >>> df1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
                            'data1': range(7)})
    >>> df2 = pd.DataFrame({'key': ['a', 'b', 'd'],
                            'data2': range(3)})
    >>> df1
       data1 key
    0      0   b
    1      1   b
    2      2   a
    3      3   c
    4      4   a
    5      5   a
    6      6   b
    
    >>> df2
       data2 key
    0      0   a
    1      1   b
    2      2   d


    # Perform a many-to-one join, since df1 has multiple rows labeled 'a' and 'b',
    #   whereas df2 only has one row for each value in the 'key' column
    >>> pd.merge(df1, df2)

       data1 key  data2
    0      0   b      1
    1      1   b      1
    2      6   b      1
    3      2   a      0
    4      4   a      0
    5      5   a      0


    # Note that if the merge key is not specified, 'merge' uses the overlapping columns
    #   as keys (but it's a best practice to specify the key explicitly)
    >>> pd.merge(df1, df2, on='key')


    # If the column manes are different in each object, they can be specified separately
    >>> df3 = pd.DataFrame({'lkey': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
                            'data1': range(7)})

    >>> df4 = pd.DataFrame({'rkey': ['a', 'b', 'd'],
                            'data2': range(3)})

    >>> pd.merge(df3, df4, left_on='lkey', right_on='rkey')



- Outer Joins

    # Take the outer join
    >>> pd.merge(df1, df2, how='outer')

       data1 key  data2
    0    0.0   b    1.0
    1    1.0   b    1.0
    2    6.0   b    1.0
    3    2.0   a    0.0
    4    4.0   a    0.0
    5    5.0   a    0.0
    6    3.0   c    NaN
    7    NaN   d    2.0



- List of Different Join Types with the 'how' Argument

    Option	    Behavior
    -----------------------------------------------------------------------
    'inner'	    Use only the key combinations observed in both tables
    'left'	    Use all key combinations found in the left table
    'right'	    Use all key combinations found in the right table
    'outer'	    Use all key combinations observed in both tables together



- Many-to-Many Merges

    # Create DataSets
    >>> df1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'b'],
                            'data1': range(6)})

    >>> df2 = pd.DataFrame({'key': ['a', 'b', 'a', 'b', 'd'],
                            'data2': range(5)})
    >>> df1
       data1 key
    0      0   b
    1      1   b
    2      2   a
    3      3   c
    4      4   a
    5      5   b
    
    >>> df2
       data2 key
    0      0   a
    1      1   b
    2      2   a
    3      3   b
    4      4   d


    # Many-to-many merge to get the Cartesian product
    >>> pd.merge(df1, df2, on='key', how='left')

        data1 key  data2
    0       0   b    1.0
    1       0   b    3.0
    2       1   b    1.0
    3       1   b    3.0
    4       2   a    0.0
    5       2   a    2.0
    6       3   c    NaN
    7       4   a    0.0
    8       4   a    2.0
    9       5   b    1.0
    10      5   b    3.0



- Merging with Multiple Keys

    >>> left = pd.DataFrame({'key1': ['foo', 'foo', 'bar'],
                             'key2': ['one', 'two', 'one'],
                             'lval': [1, 2, 3]})

    >>> right = pd.DataFrame({'key1': ['foo', 'foo', 'bar', 'bar'],
                              'key2': ['one', 'one', 'one', 'two'],
                              'rval': [4, 5, 6, 7]})

    # Merge on composite key
    >>> pd.merge(left, right, on=['key1', 'key2'], how='outer')
 
      key1 key2  lval  rval
    0  foo  one   1.0   4.0
    1  foo  one   1.0   5.0
    2  foo  two   2.0   NaN
    3  bar  one   3.0   6.0
    4  bar  two   NaN   7.0


    # Merge also has the 'suffixes' option to specify strings to append to overlaping names
    >>> pd.merge(left, right, on='key1')

      key1 key2_x  lval key2_y  rval
    0  foo    one     1    one     4
    1  foo    one     1    one     5
    2  foo    two     2    one     4
    3  foo    two     2    one     5
    4  bar    one     3    one     6
    5  bar    one     3    two     7
    
    >>> pd.merge(left, right, on='key1', suffixes=('_left', '_right'))

      key1 key2_left  lval key2_right  rval
    0  foo       one     1        one     4
    1  foo       one     1        one     5
    2  foo       two     2        one     4
    3  foo       two     2        one     5
    4  bar       one     3        one     6
    5  bar       one     3        two     7



- List of Merge Function Arguments

    Argument	       Description
    ---------------------------------------------------------------------------------
    left	           DataFrame to be merged on the left side.

    right	           DataFrame to be merged on the right side.

    how	               One of 'inner', 'outer', 'left', or 'right'; defaults to 'inner'.

    on	               Column names to join on. Must be found in both DataFrame objects. If not 
                         specified and no other join keys given, will use the intersection of 
                         the column names in left and right as the join keys.

    left_on	           Columns in left DataFrame to use as join keys.

    right_on	       Analogous to left_on for left DataFrame.

    left_index	       Use row index in left as its join key (or keys, if a MultiIndex).

    right_index	       Analogous to left_index.

    sort	           Sort merged data lexicographically by join keys; True by default (disable 
                         to get better performance in some cases on large datasets).

    suffixes	       Tuple of string values to append to column names in case of overlap; 
                         defaults to ('_x', '_y') (e.g., if 'data' in both DataFrame objects, 
                         would appear as 'data_x' and 'data_y' in result).

    copy	           If False, avoid copying data into resulting data structure in some 
                         exceptional cases; by default always copies.

    indicator          Adds a special column _merge that indicates the source of each row; 
                         values will be 'left_only', 'right_only', or 'both' based on the origin 
                         of the joined data in each row.



- Merging on Index

    In some cases, the merge key in a DataFrame will be found in its index.  In this
      case, you can pass 'left_index=True' or 'right_index=True' (or both) to indicate
      that the index should be used as the merge key.


    # Create DataFrames
    >>> left1 = pd.DataFrame({'key': ['a', 'b', 'a', 'a', 'b', 'c'],
                              'value': range(6)})

    >>> right1 = pd.DataFrame({'group_val': [3.5, 7]}, 
                               index=['a', 'b'])
    >>> left1
      key  value
    0   a      0
    1   b      1
    2   a      2
    3   a      3
    4   b      4
    5   c      5
    
    >>> right1 
       group_val
    a        3.5
    b        7.0
    

    # Use the index as the merge key
    >>> pd.merge(left1, right1, left_on='key', right_index=True)
      key  value  group_val
    0   a      0        3.5
    2   a      2        3.5
    3   a      3        3.5
    1   b      1        7.0
    4   b      4        7.0


    # Form a union with an outer join instead
    >>> pd.merge(left1, right1, left_on='key', right_index=True, how='outer')
      key  value  group_val
    0   a      0        3.5
    2   a      2        3.5
    3   a      3        3.5
    1   b      1        7.0
    4   b      4        7.0
    5   c      5        NaN



- Merging on Hierarchical Indexes

    # Create DataFrames
    >>> lefth = pd.DataFrame({'key1': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'],
                              'key2': [2000, 2001, 2002, 2001, 2002],
                              'data': np.arange(5.)})

    >>> righth = pd.DataFrame(np.arange(12).reshape((6, 2)),
                             index=[['Nevada', 'Nevada', 'Ohio', 'Ohio', 'Ohio', 'Ohio'],
                                    [2001, 2000, 2000, 2000, 2001, 2002]],
                             columns=['event1', 'event2'])
    >>> lefth
       data    key1  key2
    0   0.0    Ohio  2000
    1   1.0    Ohio  2001
    2   2.0    Ohio  2002
    3   3.0  Nevada  2001
    4   4.0  Nevada  2002
    
    >>> righth
                 event1  event2
    Nevada 2001       0       1
           2000       2       3
    Ohio   2000       4       5
           2000       6       7
           2001       8       9
           2002      10      11
    

    # Indicate multiple columns to merge on as a list 
    >>> pd.merge(lefth, righth, left_on=['key1', 'key2'], right_index=True)

       data    key1  key2  event1  event2
    0   0.0    Ohio  2000       4       5
    0   0.0    Ohio  2000       6       7
    1   1.0    Ohio  2001       8       9
    2   2.0    Ohio  2002      10      11
    3   3.0  Nevada  2001       0       1
    

    # Handle duplicate index values with how='outer'
    >>> pd.merge(lefth, righth, left_on=['key1', 'key2'], right_index=True, how='outer')

       data    key1  key2  event1  event2
    0   0.0    Ohio  2000     4.0     5.0
    0   0.0    Ohio  2000     6.0     7.0
    1   1.0    Ohio  2001     8.0     9.0
    2   2.0    Ohio  2002    10.0    11.0
    3   3.0  Nevada  2001     0.0     1.0
    4   4.0  Nevada  2002     NaN     NaN
    4   NaN  Nevada  2000     2.0     3.0



- Merging on Both Sides of a Hierarchical Index

    # Create the DataFrames
    >>> left2 = pd.DataFrame([[1., 2.], [3., 4.], [5., 6.]],
                             index=['a', 'c', 'e'],
                             columns=['Ohio', 'Nevada'])

    >>> right2 = pd.DataFrame([[7., 8.], [9., 10.], [11., 12.], [13, 14]],
                              index=['b', 'c', 'd', 'e'],
                              columns=['Missouri', 'Alabama'])
    >>> left2
       Ohio  Nevada
    a   1.0     2.0
    c   3.0     4.0
    e   5.0     6.0
    
    >>> right2
       Missouri  Alabama
    b       7.0      8.0
    c       9.0     10.0
    d      11.0     12.0
    e      13.0     14.0
    
    >>> pd.merge(left2, right2, how='outer', left_index=True, right_index=True)

       Ohio  Nevada  Missouri  Alabama
    a   1.0     2.0       NaN      NaN
    b   NaN     NaN       7.0      8.0
    c   3.0     4.0       9.0     10.0
    d   NaN     NaN      11.0     12.0
    e   5.0     6.0      13.0     14.0



- The 'join' Instance Method



- Concatenating Along An Axis

- List of 'concat' Function Arguments

- Combining Data With Overlap

- Reshaping With Hierarchical Indexing

- Pivoting 'Long' to 'Wide' Format

- Pivoting 'Wide' to 'Long' Format